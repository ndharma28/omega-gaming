{
  "language": "Solidity",
  "sources": {
    "contracts/lottery.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.2 <0.9.0; // set the version of solidity that we are using\n\ncontract Lottery {\n\n    address public owner;   // the person who deployed the contract\n    address payable[] public players;   // array of players who have entered the lottery (NOTE: we use the payable modifier for any addresses who can receive payment/eth)\n    uint public lotteryId;\n    mapping (uint => address payable) public pastWinners;\n    \n    constructor()\n    {\n        owner = msg.sender;   // owner state variable = address of the deployer of the contract\n        lotteryId = 0;\n    }\n\n    function resetLottery() public {\n        players = new address payable[](0);\n    }\n\n    function transferOwnership(address newOwner) public {\n        owner = newOwner;\n    }\n\n    function enter() public payable\n    {\n        require(msg.value > .01 ether); // enforces that the user is betting > .01 eth\n\n        players.push(payable(msg.sender));   // in this context, msg.sender is the address of the person who invoked this function\n    }\n\n    function getRandomNumber() public view returns (uint)\n    {\n        // pseudo-random number generation using the keccak256 hashing algorithm\n            // note: abi.encodePacked is the easiest way to concatenate two strings\n        return uint(keccak256(abi.encodePacked(owner, block.timestamp)));\n    }\n\n    function chooseWinner() public\n    {\n        uint index = getRandomNumber() % players.length;\n        \n        (bool success, ) = players[index].call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n\n        // increment lotteryId and pastWinners log (NOTE: make sure you update state AFTER eth transfers to protect against re-entry attacks)\n        pastWinners[lotteryId] = players[index];\n        lotteryId++;\n\n        // reset the state of the contract by creating a new players array of length 0\n        players = new address payable[](0);\n    }\n\n    // helper functions:\n    function getPotBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n    function getPlayers() public view returns (address payable[] memory)\n    {\n        return players;\n    }\n    function getWinnerByLotteryId(uint gameId) public view returns (address payable)\n    {\n        return pastWinners[gameId];\n    }\n\n    // custom modifier(s)\n    //modifier ownerOnly() \n    //{\n        //require(msg.sender == owner);\n        //_;  // this says: run whatever code follows the modifier\n    //}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}